# File: codexify/core/tree_builder.py
# ------------------------------------------------------------
import os
import fnmatch
from typing import List, Dict, Optional, Set, Any, Tuple, Union, cast

from .file_system import load_gitignore, count_contents, ParseGitignoreFuncType, GitignoreMatcher

TreeDict = Dict[str, Any]
FileEntry = Dict[str, Union[str, bool]] # 'name': str, 'omitted': bool

def build_filtered_file_list(
    root: str,
    extensions: List[str],
    exclude_dirs: List[str],
    exclude_files: List[str],
    gitignore_path: Optional[str],
    parse_gitignore_func: ParseGitignoreFuncType,
    permanent_exclusions: Set[str],
    config_pattern_yaml_local: str
) -> List[str]:
    """
    Builds a sorted list of relative file paths to be included for content compilation.

    This function walks the directory tree starting from `root` and applies
    various filters:
    -   Permanent exclusions (e.g., .git).
    -   User-defined directory exclusions (`exclude_dirs`).
    -   User-defined file exclusions (`exclude_files`).
    -   Rules from a .gitignore file, if specified.
    -   Exclusion of the local YAML configuration file itself.
    -   Inclusion based on specified `extensions`.

    Args:
        root: The absolute or relative path to the root directory to scan.
        extensions: A list of file extensions (e.g., [".py", ".txt"]) to include.
                    Extensions are matched case-insensitively.
        exclude_dirs: A list of directory names to completely exclude from traversal
                      and content inclusion.
        exclude_files: A list of file names to exclude from content inclusion.
        gitignore_path: Optional path to a .gitignore file. If provided, its rules
                        are used for filtering.
        parse_gitignore_func: The function used to parse the .gitignore file.
        permanent_exclusions: A set of file/directory names or patterns that are
                              always excluded (e.g., ".git").
        config_pattern_yaml_local: A fnmatch pattern for the YAML config files
                                   generated by this tool, to prevent them from
                                   being included in their own output.

    Returns:
        A sorted list of relative file paths (using forward slashes as separators)
        that match the inclusion criteria and are not excluded.
    """
    processed_extensions: Set[str] = {
        ext.lower() if ext.startswith('.') else '.' + ext.lower() for ext in extensions
    }
    file_list: List[str] = []

    gitignore_base_dir_for_rules: Optional[str] = None
    if gitignore_path:
        if os.path.isabs(gitignore_path):
            gitignore_base_dir_for_rules = os.path.dirname(gitignore_path)
        else: # Relative gitignore_path is resolved relative to the root of the scan
            gitignore_base_dir_for_rules = os.path.abspath(root)

    ignore_matcher: GitignoreMatcher = load_gitignore(
        gitignore_path,
        parse_gitignore_func,
        gitignore_base_dir_for_rules
    )

    abs_root = os.path.abspath(root)
    exclude_dirs_set: Set[str] = set(exclude_dirs)
    exclude_files_set: Set[str] = set(exclude_files)
    perm_exclude_set: Set[str] = permanent_exclusions

    for dirpath, dirnames, filenames in os.walk(abs_root, topdown=True):
        abs_dirpath = os.path.abspath(dirpath)

        original_dirnames = list(dirnames)
        dirnames[:] = []
        for d_name in original_dirnames:
            if d_name in perm_exclude_set: continue
            if d_name in exclude_dirs_set: continue
            abs_subdir_path = os.path.join(abs_dirpath, d_name)
            if ignore_matcher(abs_subdir_path): continue
            dirnames.append(d_name)

        rel_dirpath = os.path.relpath(abs_dirpath, abs_root)

        for filename_str in filenames:
            if filename_str in perm_exclude_set or \
               any(fnmatch.fnmatch(filename_str, pat) for pat in perm_exclude_set if '*' in pat or '?' in pat):
                continue
            if fnmatch.fnmatch(filename_str, config_pattern_yaml_local): continue
            if filename_str in exclude_files_set: continue
            full_path = os.path.join(abs_dirpath, filename_str)
            if ignore_matcher(full_path): continue
            if any(filename_str.lower().endswith(ext) for ext in processed_extensions):
                 rel_path_intermediate = os.path.join(rel_dirpath, filename_str) if rel_dirpath != '.' else filename_str
                 rel_path_normalized = rel_path_intermediate.replace(os.sep, '/')
                 file_list.append(rel_path_normalized)
    file_list.sort()
    return file_list

def build_tree_structure(
    root: str,
    use_gitignore: bool,
    gitignore_path: Optional[str],
    parse_gitignore_func: ParseGitignoreFuncType,
    permanent_exclusions: Set[str],
    user_exclude_dirs: List[str],
    user_exclude_files: List[str],
    extensions_for_content: List[str]
) -> TreeDict:
    """
    Builds a nested dictionary representing the directory tree structure.

    Each key in the dictionary is a directory or file name. Directory values
    are themselves dictionaries (TreeDict). Files are stored in a special
    `_files` key within their parent directory's dictionary, as a list of
    FileEntry dicts ({'name': str, 'omitted': bool}).
    `omitted` is True if the file's content should not be included based on
    exclusions or lack of matching extension.
    Excluded directories are marked with `_excluded_dir: True` and include
    counts of their internal (non-permanently-excluded) dirs and files.

    Args:
        root: The absolute path to the root directory for building the tree.
        use_gitignore: Whether to apply .gitignore rules.
        gitignore_path: Optional path to a .gitignore file.
        parse_gitignore_func: Function to parse the .gitignore file.
        permanent_exclusions: Set of names/patterns always excluded.
        user_exclude_dirs: List of directory names explicitly excluded by the user.
                           These are marked as [Content Omitted] in the tree.
        user_exclude_files: List of file names explicitly excluded by the user.
                            Their content is omitted.
        extensions_for_content: List of file extensions whose content is desired.
                                Files not matching these will have `omitted: True`.

    Returns:
        A TreeDict representing the directory structure with exclusion metadata.
    """
    tree: TreeDict = {}
    abs_root = os.path.abspath(root)

    gitignore_base_dir_for_rules: Optional[str] = None
    if gitignore_path and use_gitignore:
        if os.path.isabs(gitignore_path):
            gitignore_base_dir_for_rules = os.path.dirname(gitignore_path)
        else:
            gitignore_base_dir_for_rules = abs_root

    ignore_matcher: GitignoreMatcher = lambda _p: False
    if use_gitignore:
        ignore_matcher = load_gitignore(gitignore_path, parse_gitignore_func, gitignore_base_dir_for_rules)
    
    perm_exclude_set: Set[str] = permanent_exclusions
    user_exclude_dirs_set: Set[str] = set(user_exclude_dirs)
    user_exclude_files_set: Set[str] = set(user_exclude_files)
    content_extensions_set: Set[str] = {
        ext.lower() if ext.startswith('.') else '.' + ext.lower() for ext in extensions_for_content
    }
    excluded_counts_cache: Dict[str, Tuple[int, int]] = {}

    for dirpath, dirnames, filenames in os.walk(abs_root, topdown=True):
        abs_dirpath = os.path.abspath(dirpath)
        rel_dirpath = os.path.relpath(abs_dirpath, abs_root)

        path_parts = abs_dirpath.split(os.sep)
        if any(part in perm_exclude_set for part in path_parts if os.path.join(*path_parts[:path_parts.index(part)+1]) != abs_root and part != '.'):
            dirnames[:] = []
            filenames[:] = []
            continue

        current_level_node: TreeDict = tree
        if rel_dirpath != '.':
            parts = rel_dirpath.split(os.sep)
            path_is_valid = True
            for part_idx, part in enumerate(parts):
                child_node_any = current_level_node.get(part)

                if not isinstance(child_node_any, dict):
                    is_parent_excluded = False
                    temp_node_check: TreeDict = tree
                    for p_check in parts[:part_idx+1]:
                        node_val_any = temp_node_check.get(p_check)
                        if isinstance(node_val_any, dict):
                            node_val_as_treedict = cast(TreeDict, node_val_any)
                            if node_val_as_treedict.get("_excluded_dir"):
                                is_parent_excluded = True
                                break
                            temp_node_check = node_val_as_treedict
                        else:
                            is_parent_excluded = True
                            break
                    
                    if is_parent_excluded:
                        dirnames[:] = []
                        filenames[:] = []
                        path_is_valid = False
                        break
                    
                    new_child_node: TreeDict = {}
                    current_level_node[part] = new_child_node
                    current_level_node = new_child_node
                else:
                    current_level_node = cast(TreeDict, child_node_any)

                if current_level_node.get("_excluded_dir"):
                    dirnames[:] = []
                    filenames[:] = []
                    path_is_valid = False
                    break
            if not path_is_valid:
                continue
        
        original_dirnames = list(dirnames)
        dirnames[:] = []
        for d_name in original_dirnames:
            if d_name in perm_exclude_set:
                continue

            abs_subdir_path = os.path.join(abs_dirpath, d_name)
            is_user_dir_excluded_explicitly = d_name in user_exclude_dirs_set
            is_dir_ignored_by_git: bool = use_gitignore and ignore_matcher(abs_subdir_path)

            if is_user_dir_excluded_explicitly or is_dir_ignored_by_git:
                if abs_subdir_path not in excluded_counts_cache:
                     d_count, f_count = count_contents(abs_subdir_path, perm_exclude_set)
                     excluded_counts_cache[abs_subdir_path] = (d_count, f_count)
                else:
                     d_count, f_count = excluded_counts_cache[abs_subdir_path]
                current_level_node[d_name] = {"_excluded_dir": True, "_dir_count": d_count, "_file_count": f_count, "_files": []} # type: ignore
            else:
                current_level_node.setdefault(d_name, {})
                dirnames.append(d_name)

        node_files_list_any = current_level_node.get("_files")
        if node_files_list_any is None or not isinstance(node_files_list_any, list):
            files_in_node: List[FileEntry] = []
            current_level_node["_files"] = files_in_node # type: ignore
        else:
            files_in_node = cast(List[FileEntry], node_files_list_any)

        for filename_str in filenames:
            if filename_str in perm_exclude_set or \
               any(fnmatch.fnmatch(filename_str, pat) for pat in perm_exclude_set if '*' in pat or '?' in pat):
                continue

            full_path = os.path.join(abs_dirpath, filename_str)
            is_content_omitted_by_user_rule = filename_str in user_exclude_files_set
            is_content_omitted_by_gitignore: bool = use_gitignore and ignore_matcher(full_path)
            is_content_omitted_by_extension: bool = bool(content_extensions_set and not any(filename_str.lower().endswith(ext) for ext in content_extensions_set))
            is_content_omitted: bool = is_content_omitted_by_user_rule or is_content_omitted_by_gitignore or is_content_omitted_by_extension
            files_in_node.append({'name': filename_str, 'omitted': is_content_omitted})

        if files_in_node:
             files_in_node.sort(key=lambda file_entry: file_entry['name'])
        elif "_files" in current_level_node and not current_level_node.get("_files"):
             current_level_node.pop("_files")
    return tree

def print_tree(
    tree: TreeDict,
    root_display_name: Optional[str] = None,
    indent: str = "",
    is_last_entry_in_parent: bool = True
) -> List[str]:
    """
    Generates a list of strings representing the formatted directory tree.

    Args:
        tree: The TreeDict structure (nested dictionaries) to print.
        root_display_name: If provided, this name is printed as the root of the tree.
                           If None, the function assumes it's printing a sub-tree.
        indent: The string prefix for indentation of the current level.
        is_last_entry_in_parent: Flag indicating if the current tree/node being printed
                                 is the last child of its parent. Affects connectors.

    Returns:
        A list of strings, where each string is a line in the formatted tree.
    """
    lines: List[str] = []
    current_prefix = indent

    if root_display_name is not None:
        lines.append(root_display_name)
        current_prefix = ""

    dir_items: List[Tuple[str, TreeDict]] = []
    raw_files_any = tree.get("_files", [])
    file_items_from_tree: List[FileEntry] = []

    if isinstance(raw_files_any, list):
        typed_raw_files = cast(List[FileEntry], raw_files_any) # Elements are expected to be FileEntry
        for item_entry in typed_raw_files:
            # Since typed_raw_files is cast to List[FileEntry] and FileEntry is a Dict,
            # item_entry is already known to be a dict if the cast is correct.
            # The isinstance(item_entry, dict) check is redundant if the structure is consistent.
            file_items_from_tree.append(item_entry)


    for key, value_any in tree.items():
        if key == "_files": continue
        if isinstance(value_any, dict):
            value_as_treedict: TreeDict = cast(TreeDict, value_any)
            dir_items.append((key, value_as_treedict))

    dir_items.sort(key=lambda item_lambda: (bool(item_lambda[1].get("_excluded_dir")), item_lambda[0].lower()))
    all_entries_count = len(dir_items) + len(file_items_from_tree)
    entry_index = 0

    for dir_name, dir_content_node in dir_items:
        entry_index += 1; is_last = (entry_index == all_entries_count)
        connector = "└── " if is_last else "├── "
        if dir_content_node.get("_excluded_dir"):
            dir_count = dir_content_node.get('_dir_count', 0)
            file_count = dir_content_node.get('_file_count', 0)
            lines.append(f"{current_prefix}{connector}{dir_name}/ [Content Omitted: Dirs: {dir_count}, Files: {file_count}]")
        else:
            lines.append(f"{current_prefix}{connector}{dir_name}/")
            child_indent = current_prefix + ("    " if is_last else "│   ")
            lines.extend(print_tree(dir_content_node, root_display_name=None, indent=child_indent, is_last_entry_in_parent=is_last))

    for file_data in file_items_from_tree:
        entry_index += 1; is_last = (entry_index == all_entries_count)
        connector = "└── " if is_last else "├── "
        filename_str = file_data.get('name', 'UnknownFile')
        omitted_suffix = " [Content Omitted]" if file_data.get('omitted', True) else ""
        lines.append(f"{current_prefix}{connector}{filename_str}{omitted_suffix}")
    return lines